// Делаем ТАБы на странице с блоком услуг
window.addEventListener('DOMContentLoaded', function () {                      // Необходимо вещать такие обработчики в самом начале на любом проекте, т.к. когда грузится js он не знает прогрузилась ли страница у пользователя полностью или нет. Может там картинки большие и еще ничего не прогрузилось? А js начнет выполнять с этими элементами действия. Так нельзя. Поэтому вешая обрабочик на window load после того как загрузится ВСЯ страница (картинки,иконки, меню и другие элементы), только тогда наш js начнет выполняться! НО лучше ипользовать событие DOMContentLoaded - это значит, что картинки некоторые могут быть не загружены, но главное, чтобы был постороен весь наш DOM дерево проекта. Короче говоря когда построено все дом дерево (все теги и так далее), тогда и js выполнится.
    'use strict';                                                              // Переводим наш код в строгий режим, т.к. никакой ошибки быть не должно в частности и в переменных
    let tab         = document.querySelectorAll('.info-header-tab'),           // Получили все наши кнопки (Лечение, отдых, природа, йога)
        info        = document.querySelector('.info-header'),                  // Получили родителя наших кнопок
        tabContent  = document.querySelectorAll('.info-tabcontent');           // Получили все наше содержимое (т.е. информацию о каждом виде услуги)

    function hideTabContent (a) {                                              // Создаем функцию, которая будет закрывать наши ТАБЫ. Данная функция принимает технический аргумент a, для того, чтобы задать проход нашего цикла начался не с 0, а с 1, чтобы 1 объект был виден на странице, а не скрывалось все
        for (let i = a; i < tabContent.length; i++) {                          // Приравниваем наш i под нашу техническую переменную, которую мы создали в функции. Далее i должна быть меньше наших контент блоков в верстке
            tabContent[i].classList.remove('show');                            // При каждом проходе цикла мы будем использовать наш tabContent начиная с 1 и заканчивая последним, т.е. под скрытие. Далее удаляем наш класс с помощью classList.remove класс show удаляем (это в верстве)
            tabContent[i].classList.add('hide');                               // Соответственно класс show, при котором наши элементы показывались мы удалили выше, а класс hide ествественно добавили, чтобы скрыть все элементы

        }
    };
    hideTabContent(1);                                                         // Т.е. наш технический параметр нужен чтобы начать проход цикла с 1, а не с 0. Т.е. у нас будут скрыты все элементы начиная с 1, но тот элемент который мы видим на странице (0 элемент) останется и будет виден

    function showTabContent (b) {                                              // Создаем функцию на показ теперь нужных нам табов на странице. Технический аргумент b нужен будет для того, чтобы показать именно тот ТАБ (контент) который нам необходим
        if(tabContent[b].classList.contains('hide')) {                         // Делаем проверку на то, а правда ли наш элемент скрыт или он как раз 0 и виден пользователю
            tabContent[b].classList.remove('hide');                            // Соответвенно противоположные функции и дейтвия на показ какого-то определенного ТАБа на странице                        
            tabContent[b].classList.add('show');  

        }
    };

    info.addEventListener('click', function (event) {                          // Создаем функцию, которая будет работаь при клике на наши подменю скрывать и добавлять наши ТАБы, по принципи дилигирования делам, т.е. вешаем обработчик клика сразу на все меню, а не на отдельные элементы
        let target = event.target;                                             // Переменная, в которой показыаается событие клика, т.е. непосредственно элемент на который мы кликнули

        if (target && target.classList.contains('info-header-tab')) {          // Выполняется проверка по клику и проверем на какой же элемент конкретно мы кликнули, а должны мы кликнуть на одну из кнопок с классом info-header-tab
            for (let i = 0; i < tab.length; i++) {                             // Нам нужно определить какая из кнопок с каким вообще связана элементом. Т.е. надо понять, что отдых связан с Антистрессом и так далее в верстке. Соответственно пройти мы это можем циклом и определить на какую кнопку тыкнули
                if (target == tab[i]) {                                        // Здесь делаем проверку, если наш таргет (то куда мы назажи) совпадает с нашим табом (куда кликнули), то...
                    hideTabContent(0);                                         // Вызываем нашу функцию на скрытие всех наших табов и теперь здесь можно скрыть абсолютно все наши табы
                    showTabContent(i);                                         // Т.е. мы в цикле использовали i, т.е. допустим это 3 или 2 или 4 tab наш в верстке и оно проверит какой именно элемент показывать
                    break;                                                     // Останавливаем наш цикл принудительно
                }                                                                                         
            }                                                                                                                                                 
        }
    }); // Что такое вообще табы? Мы будем работать с табами на странице - это когда мы хотим, чтобы наше меню там где описание услуги и прочее показывалось только при тыкании на кнопку или подгружалось бы. Для того, чтобы начать работать с этим нам надо полчить родительский блок где эти все табы, далее все элементы внутри

// Делаем интерактивный таймер обратного отсчета на нашей странице
    let deadLine = '2019-08-08';                                      // Создаем дату до которой мы должны дойти в конечном итоге, т.е. наш таймер остановится, когда мы дойдем до этой даты, ну т.е. скидка закончится в то время, когда мы дойдем до этого числа

    function getTimeRemaining (endtime) {                             // Создаем функцию в которой будем узнавать промежуток времени в котором мы сейчас и сколько до того самого deadLine, которое мы задали в переменную. В endtime мы как раз и будем передавать дату будущую до которой должны дойти
        let t       = Date.parse(endtime) - Date.parse(new Date),     // Создаем переменную в которой мы берем дату которая будет когда-то и отнимаем дату, которая сейчас в реальном времени, получаем разницу и записываем это в переменную. Сейчас в t лежит кол-во милисекунд от нашего реального времени до deadLine. Метод parse() - превращает любую дату в кол-во милисекунд. И в первом аргументе мы передаем нашу большую дату, т.е. наш deadLine. И от него отнимаем дату, которая есть прямо сейчас, т.е. новая дата реального времени. Это как раз и делается с помощью new Date. Соответственно получили в переменной t разницу между датами и записали все в нее.
            seconds = Math.floor((t/1000) % 60),                      // Поскольку на сайте у нас 3 параметра, а именно секунды, минуты и часы, то нам надо это из милисекунд преобразовать в нужные времена. Для этого первым делом мы используем метод Math.floor, который позволит нам получать целые числа. Соответственно дальше мы должны получить кол-во секунд из наших милисекунд, собственно вот так: (t/1000) - это мы получим чистые секунды, но беда в том, что получаем мы его в большом кол-ве, а должно быть секунд не более 60, а значит нам надо делить на 60 с остатком с помощью %
            minutes = Math.floor((t/1000/60) % 60),                   // Аналогично как и с секундами, но только формула по рассчету минут уже другая конечно
            hours   = Math.floor((t/(1000*60*60)));                   // Аналогично как и с секундами, но только формула по рассчету часов уже другая конечно

            // hours   = Math.floor((t/1000/60/60) % 24),             // Это как аналогия, если бы мы хотели получать еще и дни, если бы к примеру оно у нас было бы в верстке
            // days    = Math.floor((t/(1000*60*60*24)));

        return {                                                      // Так как из функции несколько переменных мы экспортировать не можем, то можем создать как бы объект return, которая будет возвращать что-то, а именно параметры, которые мы напишем чуть позже. Т.е. здесь мы вычленили часы, минуты, секунды и то время, когда таймер должен остановиться
            'total'     : t,                                          // Здесь мы оставим то, что когда мы дойдем до нашего total, то таймер будет остановлен
            'hours'     : hours,                                      // Здесь будут часы
            'minutes'   : minutes,                                    // Здесь будут минуты
            'seconds'   : seconds                                     // Здесь будут секунды
        };
    };

    function setClock (id, endtime) {                                 // Создаем функцию, которая превращает нашу статичную верстку в динамическую, т.е. чтобы наши цифры который мы рассчитывали менялись прямо в верстке. id - это поиск элемента на нашем сайте, т.е. куда подставлять наши получившиеся значения (это из верстки). И второй аргумент andTime - то наше финишное время куда мы должны прийти, т.е наш deadLine
        let timer = document.getElementById(id),                      // Получаем наш сам таймер через id и в скобочках пишем естественно уже как аргумент. Далее ниже получаем все наши элементы из верстки, которые необходимы для работы (мы их получаем как бы)
            hours = timer.querySelector('.hours'),
            minutes = timer.querySelector('.minutes'),
            seconds = timer.querySelector('.seconds'),
            timeInterval = setInterval(updateClock, 1000);            // Создаем переменную в которой запускаем нашу функцию updateClock спустя каждые 1000 милисекунд, ну т.е. каждую секунду

        function updateClock () {                                     // Создаем функцию, которая собственно будет каждый раз менять наши параметры в верстве через каждую секунду с помощью метода setInterval
            let t = getTimeRemaining(endtime);                        // Снова создаем техническую переменную в которой вызывается наша функция по получению времени и преобразованию с аргументом до которого нам надо идти

            function addZero(num){                                    // Здесь создаем функцию, которая в случае если в таймере цифр меньше 2, то чтобы приписывался 0 перед этим числом
                if(num <= 9) {
                    return '0' + num;
                } else return num;
            };

            hours.textContent   = addZero(t.hours);                   // Получаем доступ к нашей верстке и меняем в ней соответственно наше время по часам, минутам и секундам. В переменной t сейчас объект, собственно так мы и получаем через точку доступ к нужному нам времени
            minutes.textContent = addZero(t.minutes);
            seconds.textContent = addZero(t.seconds);

            if (t.total <= 0) {                                       // Здесь останавливаем наш скрипт, когда мы собственно дойдем до нашей даты, до нашего deadLine. Чтобы акция не шла дальше в минус. Ну а именно под проверку мы пишем, что если наши милисекунды, которые мы получали меньше либо равны 0, то скрипт будет остановлен
                clearInterval(timeInterval);                          // Останавливаем наш интервал, а каким именно пишем в скобочках
                hours.textContent   = '00';                           // Когда остановка произошла принудительно записываем одни 00 в наши значения
                minutes.textContent = '00';
                seconds.textContent = '00';
            }
        };
    };
    setClock('timer', deadLine);                                      // Соответственно в ковычках передаем id по которому будем искать и через запятую нашу переменную deadLine, а именно финишное значение
});
