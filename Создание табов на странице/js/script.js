// Делаем ТАБы на странице с блоком услуг
window.addEventListener('DOMContentLoaded', function () {                      // Необходимо вещать такие обработчики в самом начале на любом проекте, т.к. когда грузится js он не знает прогрузилась ли страница у пользователя полностью или нет. Может там картинки большие и еще ничего не прогрузилось? А js начнет выполнять с этими элементами действия. Так нельзя. Поэтому вешая обрабочик на window load после того как загрузится ВСЯ страница (картинки,иконки, меню и другие элементы), только тогда наш js начнет выполняться! НО лучше ипользовать событие DOMContentLoaded - это значит, что картинки некоторые могут быть не загружены, но главное, чтобы был постороен весь наш DOM дерево проекта. Короче говоря когда построено все дом дерево (все теги и так далее), тогда и js выполнится.
    'use strict';                                                              // Переводим наш код в строгий режим, т.к. никакой ошибки быть не должно в частности и в переменных
    let tab         = document.querySelectorAll('.info-header-tab'),           // Получили все наши кнопки (Лечение, отдых, природа, йога)
        info        = document.querySelector('.info-header'),                  // Получили родителя наших кнопок
        tabContent  = document.querySelectorAll('.info-tabcontent');           // Получили все наше содержимое (т.е. информацию о каждом виде услуги)

    function hideTabContent (a) {                                              // Создаем функцию, которая будет закрывать наши ТАБЫ. Данная функция принимает технический аргумент a, для того, чтобы задать проход нашего цикла начался не с 0, а с 1, чтобы 1 объект был виден на странице, а не скрывалось все
        for (let i = a; i < tabContent.length; i++) {                          // Приравниваем наш i под нашу техническую переменную, которую мы создали в функции. Далее i должна быть меньше наших контент блоков в верстке
            tabContent[i].classList.remove('show');                            // При каждом проходе цикла мы будем использовать наш tabContent начиная с 1 и заканчивая последним, т.е. под скрытие. Далее удаляем наш класс с помощью classList.remove класс show удаляем (это в верстве)
            tabContent[i].classList.add('hide');                               // Соответственно класс show, при котором наши элементы показывались мы удалили выше, а класс hide ествественно добавили, чтобы скрыть все элементы

        }
    };
    hideTabContent(1);                                                         // Т.е. наш технический параметр нужен чтобы начать проход цикла с 1, а не с 0. Т.е. у нас будут скрыты все элементы начиная с 1, но тот элемент который мы видим на странице (0 элемент) останется и будет виден

    function showTabContent (b) {                                              // Создаем функцию на показ теперь нужных нам табов на странице. Технический аргумент b нужен будет для того, чтобы показать именно тот ТАБ (контент) который нам необходим
        if(tabContent[b].classList.contains('hide')) {                         // Делаем проверку на то, а правда ли наш элемент скрыт или он как раз 0 и виден пользователю
            tabContent[b].classList.remove('hide');                            // Соответвенно противоположные функции и дейтвия на показ какого-то определенного ТАБа на странице                        
            tabContent[b].classList.add('show');  

        }
    };

    info.addEventListener('click', function (event) {                          // Создаем функцию, которая будет работаь при клике на наши подменю скрывать и добавлять наши ТАБы, по принципи дилигирования делам, т.е. вешаем обработчик клика сразу на все меню, а не на отдельные элементы
        let target = event.target;                                             // Переменная, в которой показыаается событие клика, т.е. непосредственно элемент на который мы кликнули

        if (target && target.classList.contains('info-header-tab')) {          // Выполняется проверка по клику и проверем на какой же элемент конкретно мы кликнули, а должны мы кликнуть на одну из кнопок с классом info-header-tab
            for (let i = 0; i < tab.length; i++) {                             // Нам нужно определить какая из кнопок с каким вообще связана элементом. Т.е. надо понять, что отдых связан с Антистрессом и так далее в верстке. Соответственно пройти мы это можем циклом и определить на какую кнопку тыкнули
                if (target == tab[i]) {                                        // Здесь делаем проверку, если наш таргет (то куда мы назажи) совпадает с нашим табом (куда кликнули), то...
                    hideTabContent(0);                                         // Вызываем нашу функцию на скрытие всех наших табов и теперь здесь можно скрыть абсолютно все наши табы
                    showTabContent(i);                                         // Т.е. мы в цикле использовали i, т.е. допустим это 3 или 2 или 4 tab наш в верстке и оно проверит какой именно элемент показывать
                    break;                                                     // Останавливаем наш цикл принудительно
                }                                                                                         
            }                                                                                                                                                 
        }
    }); // Что такое вообще табы? Мы будем работать с табами на странице - это когда мы хотим, чтобы наше меню там где описание услуги и прочее показывалось только при тыкании на кнопку или подгружалось бы. Для того, чтобы начать работать с этим нам надо полчить родительский блок где эти все табы, далее все элементы внутри

// Делаем интерактивный таймер обратного отсчета на нашей странице
    let deadLine = '2019-07-22';                        // Создаем дату до которой мы должны дойти в конечном итоге, т.е. наш таймер остановится, когда эта дата будет в реальном времени

    function getTimeRemaining (endtime) {               // Создаем функцию
        let t       = Date.parse(endtime) - Date.parse(new Date),             // Создаем переменную в которой мы берем дату которая будет когда-то и отнимаем дату, которая сейчас в реальном времени, получаем разницу и записываем это в переменную. Сейчас в t лежит кол-во милисекунд
            seconds = Math.floor((t/1000) % 60),
            minutes = Math.floor((t/1000/60) % 60),
            hours   = Math.floor((t/(1000*60*60)));

        return {
            'total': t,
            'hours': hours,
            'minutes': minutes,
            'seconds': seconds
        };
    };

    function setClock (id, endtime) {
        let timer = document.getElementById(id),
            hours = timer.querySelector('.hours'),
            minutes = timer.querySelector('.minutes'),
            seconds = timer.querySelector('.seconds'),
            timeInterval = setInterval(updateClock, 1000);

        function updateClock () {
            let t = getTimeRemaining(endtime);
            hours.textContent = t.hours;
            minutes.textContent = t.minutes;
            seconds.textContent = t.seconds;

            if (t.total <= 0) {
                clearInterval(timeInterval);
            }
        };
    };
    setClock('timer', deadLine);
});
